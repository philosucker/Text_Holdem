# generate_files(5000, 100, 100, 'test_files')  : I/O Bound

Sync time: 43.93 seconds
AsyncIO time: 77.73 seconds
Multiprocessing time: 7.14 seconds
AsyncIO with multiprocessing time: 18.40 seconds

Sync time: 26.88 seconds
AsyncIO time: 89.78 seconds
Multiprocessing time: 6.60 seconds
AsyncIO with multiprocessing time: 20.10 seconds


디스크 I/O 작업에서는 비동기의 장점이 충분히 발휘되지 않을 수 있음. 
비동기 처리가 디스크 I/O에서 오히려 오버헤드로 작용할 수 있습니다.

# I/O 바운드 작업에서 멀티프로세싱이 가장 빠른 이유 
I/O 바운드 작업에서는 프로세스가 데이터 읽기/쓰기와 같은 I/O 작업을 기다리는 동안 
다른 작업을 수행할 수 없는 상태가 자주 발생합니다. 
멀티프로세싱을 통해 이러한 대기 시간을 줄이고, 
I/O 장치가 준비될 때까지 다른 작업을 수행할 수 있게 되어 전체 작업 시간이 단축됩니다.

구체적인 이유는 다음과 같습니다:

### 1. **동시성 향상**
멀티프로세싱을 사용하면 여러 프로세스가 동시에 실행됩니다. 
I/O 바운드 작업에서는 I/O 장치(예: 디스크)가 데이터를 읽거나 쓰는 동안 CPU는 대부분의 시간을 대기 상태로 보내게 됩니다. 여러 프로세스를 사용하면, 하나의 프로세스가 I/O 작업을 기다리는 동안 
다른 프로세스는 다른 파일에 데이터를 쓰거나 읽을 수 있습니다. 이를 통해 전체적인 작업 처리율이 증가합니다.

### 2. **GIL 회피**
파이썬의 CPython 인터프리터는 Global Interpreter Lock(GIL)이라는 메커니즘을 사용하여 
한 번에 하나의 스레드만 파이썬 바이트코드를 실행할 수 있도록 제한합니다. 
이로 인해 멀티스레딩을 사용하는 경우에도 동시에 실행되는 것은 단 하나의 스레드뿐입니다. 
그러나 멀티프로세싱은 각 프로세스가 별도의 메모리 공간을 가지므로, GIL의 제약을 받지 않습니다. 
따라서 멀티프로세싱을 사용하면 여러 CPU 코어를 활용하여 동시에 작업을 수행할 수 있습니다.

### 3. **I/O 대기 시간 최적화**
I/O 바운드 작업에서는 디스크 또는 네트워크 I/O의 대기 시간이 주된 병목이 됩니다. 
멀티프로세싱을 통해 여러 프로세스가 동시에 I/O 작업을 요청할 수 있으므로, 
하나의 I/O 작업이 완료될 때까지 다른 프로세스에서 다른 I/O 작업을 처리할 수 있습니다. 
이는 단일 프로세스가 I/O 작업을 기다리며 아무 작업도 수행하지 않는 시간을 줄여줍니다.

### 4. **프로세스 간 독립성**
프로세스 간의 독립성은 멀티프로세싱의 큰 장점 중 하나입니다. 
각 프로세스는 자체 메모리 공간을 가지고 있어 다른 프로세스의 작업에 영향을 미치지 않습니다. 
이로 인해 프로세스 간의 데이터 경합을 최소화하고, 안정적인 병렬 처리가 가능합니다.

결론적으로, 멀티프로세싱은 I/O 바운드 작업에서 대기 시간을 효과적으로 줄이고, 
동시에 여러 I/O 작업을 병렬로 처리할 수 있어 성능을 크게 향상시킬 수 있습니다.


# 멀티프로세싱만 사용한 경우가 비동기 I/O(`asyncio`)와 멀티프로세싱을 함께 사용한 경우보다 더 빠른 이유

### 1. **멀티프로세싱의 Overhead 감소**
멀티프로세싱은 여러 프로세스에서 작업을 병렬로 수행하므로, 각 프로세스가 독립적으로 파일을 처리합니다. 이 방식은 `asyncio`와 같은 추가적인 비동기 작업 스케줄링을 필요로 하지 않기 때문에, 오버헤드가 줄어듭니다.

반면, `asyncio`와 멀티프로세싱을 함께 사용하는 경우, 비동기 작업을 관리하기 위한 추가적인 오버헤드가 발생합니다. 각 프로세스가 `asyncio` 이벤트 루프를 운영해야 하고, 이 과정에서 코루틴의 스케줄링 및 상태 관리가 필요하기 때문에 성능에 부정적인 영향을 미칠 수 있습니다.

### 2. **I/O 작업의 비동기적 이점 부족**
비동기 I/O는 일반적으로 네트워크 요청과 같이 대기 시간이 길고, I/O 작업을 병렬로 수행할 수 있는 상황에서 가장 큰 이점을 제공합니다. 그러나 파일 쓰기와 같은 디스크 I/O 작업에서는 대기 시간이 상대적으로 짧으며, 비동기 작업의 이점이 덜 발휘됩니다. 또한, 멀티프로세싱을 사용하면 각 프로세스가 독립적으로 파일을 처리할 수 있기 때문에, 비동기 작업이 줄 수 있는 이점이 상대적으로 적습니다.

### 3. **GIL의 영향 회피**
비동기 I/O는 보통 단일 스레드에서 실행되며, 파이썬의 Global Interpreter Lock(GIL)에 의해 제약을 받습니다. 반면, 멀티프로세싱은 여러 프로세스를 사용하여 GIL의 영향을 피하고, 여러 CPU 코어를 효과적으로 사용할 수 있습니다. 이는 멀티프로세싱이 단순히 비동기 I/O보다 더 많은 병렬 처리가 가능하다는 의미입니다.

### 4. **디스크 I/O의 병목**
파일 생성 및 쓰기 작업은 주로 디스크 I/O 성능에 의해 제한됩니다. 멀티프로세싱을 사용하면 여러 프로세스가 동시에 파일을 쓸 수 있기 때문에, 디스크 I/O의 대기 시간이 병목이 되는 경우를 피할 수 있습니다. 그러나 비동기 I/O는 주로 단일 프로세스에서 작동하며, 이는 디스크 I/O 대기 시간을 충분히 활용하지 못할 수 있습니다.

### 결론
멀티프로세싱만을 사용한 방법이 비동기 I/O와 멀티프로세싱을 함께 사용한 방법보다 더 효율적인 이유는, 전자가 I/O 바운드 작업의 병목을 보다 효과적으로 해소하고, 비동기 작업의 오버헤드를 피할 수 있기 때문입니다. 따라서, I/O 바운드 작업에서는 멀티프로세싱이 비동기 I/O보다 더 좋은 성능을 발휘할 수 있습니다.