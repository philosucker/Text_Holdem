# generate_files(10000, 2000, 10)

Sync time: 104.03 seconds
AsyncIO time: 522.78 seconds generate_files(5000, 1000, 10) 절반으로 줄였는데도 멀티프로세싱보다 느리다
Multiprocessing time: 27.38 seconds 
AsyncIO with multiprocessing time: 348.51 seconds

Sync time: 101.86 seconds
AsyncIO time: 672.01 seconds
Multiprocessing time: 27.13 seconds
AsyncIO with multiprocessing time: 393.95 seconds

# 비동기 I/O(`asyncio`) 버전이 가장 오래 걸리는 이유는 주로 다음과 같은 요인에 기인합니다

### 1. **비동기 작업의 오버헤드**
비동기 프로그래밍에서는 이벤트 루프와 코루틴을 관리하는 오버헤드가 존재합니다. 특히 `aiofiles`와 같은 라이브러리를 사용하여 비동기 파일 쓰기를 수행할 때, 파일 쓰기 작업이 코루틴으로 실행되며, 각 코루틴이 이벤트 루프에 의해 스케줄링됩니다. 이 과정에서 추가적인 오버헤드가 발생할 수 있습니다.

### 2. **파일 시스템의 비동기 처리 한계**
비동기 I/O는 일반적으로 네트워크 I/O와 같은 높은 지연 시간이 발생할 수 있는 작업에서 큰 이점을 제공합니다. 그러나 파일 시스템에서의 비동기 I/O는 그다지 효율적이지 않을 수 있습니다. 이는 디스크가 물리적 장치로서 일정한 속도로 데이터를 읽고 쓰는 데 한계가 있기 때문입니다. 즉, 디스크 I/O의 속도 자체가 비동기 I/O의 효율성을 제한할 수 있습니다.

### 3. **단일 스레드의 제한**
`asyncio`는 기본적으로 단일 스레드에서 동작하며, 파일 쓰기 작업이 한 번에 한 파일씩 순차적으로 진행됩니다. 이로 인해 여러 파일에 대한 비동기적 접근이 오히려 병목이 될 수 있습니다. 반면 멀티프로세싱을 사용하면 여러 프로세스가 병렬로 파일에 접근할 수 있어, 디스크 I/O를 보다 효율적으로 사용할 수 있습니다.

### 4. **비동기 I/O의 장점 부족**
비동기 I/O는 비동기적인 작업을 효율적으로 처리하는 데 유리하지만, 각 파일 쓰기 작업이 비동기적으로 실행되면서 발생하는 대기 시간은 디스크 I/O 작업에서는 크게 감소하지 않습니다. 즉, 네트워크 I/O와 달리 디스크 I/O에서는 비동기적인 대기 시간 감소의 이점이 작습니다.

### 결론
비동기 I/O는 네트워크 I/O와 같은 대기 시간이 긴 작업에서 큰 장점을 제공하지만, 디스크 I/O와 같은 작업에서는 오히려 오버헤드가 더 클 수 있습니다. 특히, 파일을 비동기적으로 쓰는 경우 이벤트 루프와 코루틴 관리의 오버헤드가 발생하고, 디스크의 물리적 속도에 의해 제한받을 수 있습니다.

반면 멀티프로세싱을 사용하면 여러 프로세스가 병렬로 파일을 처리할 수 있어, I/O 성능을 극대화할 수 있습니다. 따라서, 주어진 작업에서는 멀티프로세싱이 가장 빠른 방법이 될 수 있습니다.