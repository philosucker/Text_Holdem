

Uvicorn을 사용하여 FastAPI 애플리케이션을 실행할 때 기본적으로 HTTP 프로토콜을 사용합니다. 

HTTPS를 사용하려면 SSL 인증서를 설정하거나 Nginx와 같은 리버스 프록시 서버를 사용해야 합니다.
Nginx와 같은 리버스 프록시 서버를 사용하여 HTTPS 요청을 처리하고, 이를 Uvicorn 서버로 전달합니다.

웹소켓 연결시 웹소켓 연결 신청 및 웹소켓을 통한 통신 모두 Nginx를 거친다.

웹소켓은 클라이언트와 서버 간의 양방향 통신을 가능하게 하는 프로토콜입니다.
주로 실시간 애플리케이션에서 사용되며, HTTP와는 다른 독립적인 프로토콜입니다.

양방향 통신: 클라이언트와 서버가 서로 실시간으로 데이터를 주고받을 수 있습니다.
지속적인 연결: 웹소켓 연결이 한 번 설정되면, 클라이언트와 서버 간의 연결이 유지됩니다.
낮은 오버헤드: HTTP에 비해 헤더 오버헤드가 적어서 더 빠르고 효율적입니다.

질문1) Nginx를 사용했을 때 FastAPI 서버와 클라이언트가 웹소켓을 연결해 통신하는 경우
HTTP랑은 다른 프로토콜을 사용한다는 거고 그 통신이 모두 Nginx를 거친다는 건가? yes
Nginx는 HTTP 뿐만 아니라 웹소켓을 위한 프로토콜 등 다른 프로토콜 통신도 지원을 한다는 건가? yes

    Nginx는 HTTP뿐만 아니라 WebSocket과 같은 다른 프로토콜의 통신도 지원합니다.
     웹소켓은 전이중(Full-Duplex) 통신을 제공하는 프로토콜로, 
     클라이언트와 서버 간의 지속적인 연결을 통해 실시간으로 데이터를 교환할 수 있습니다. 
     Nginx는 이러한 웹소켓 프로토콜을 프록시할 수 있으며, 이를 통해 클라이언트와 FastAPI 서버 간의 통신을 중계할 수 있습니다.

    Nginx와 WebSocket
    Nginx는 웹소켓 연결을 프록시할 때 HTTP 업그레이드 메커니즘을 사용합니다. 
    기본적으로 웹소켓 연결은 HTTP 핸드셰이크로 시작되며, 클라이언트는 Upgrade와 Connection 헤더를 포함하여 서버에 요청을 보냅니다. 
    서버는 이 요청을 받아들여 연결을 업그레이드하고, HTTP 연결이 웹소켓 연결로 전환됩니다.

    Nginx는 이 과정에서 중요한 역할을 합니다. Nginx는 클라이언트의 웹소켓 연결 요청을 받아들이고, 
    이를 백엔드의 FastAPI 서버로 전달합니다. 이때 Nginx는 다음과 같은 설정을 사용하여 웹소켓 연결을 처리합니다:

    server {
        listen 80;

        location /ws/ {
            proxy_pass http://backend;
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection "upgrade";
            proxy_set_header Host $host;
        }
    }

    이 설정에서 중요한 부분은 proxy_set_header 지시문으로, 
    Upgrade와 Connection 헤더를 설정하여 Nginx가 웹소켓 업그레이드를 처리할 수 있도록 하는 것입니다. 
    이를 통해 클라이언트와 서버 간의 웹소켓 연결이 Nginx를 통해 원활하게 프록시됩니다.


메시지 브로커는 시스템 간에 메시지를 전송하고 라우팅하는 역할을 하는 미들웨어 소프트웨어입니다. 
주로 분산 시스템에서 컴포넌트 간의 통신을 쉽게 하기 위해 사용됩니다.

메시지 큐잉: 메시지를 특정 큐에 저장하고, 큐에 있는 메시지를 소비자가 읽을 때까지 대기합니다.
퍼블리시/서브스크라이브(Pub/Sub): 메시지를 특정 주제(topic)로 게시하고, 해당 주제에 구독한 소비자들에게 메시지를 전달합니다.
라우팅: 메시지를 특정 기준에 따라 라우팅합니다. 예를 들어, 특정 조건을 만족하는 메시지만 특정 큐나 소비자에게 전달합니다.
순서 보장: 메시지가 전송된 순서대로 소비자에게 전달되도록 보장합니다.

RabbitMQ, Apache Kafka, ActiveMQ 등이 대표적인 메시지 브로커입니다.
분산 시스템에서 서로 다른 서비스 간의 통신을 위해 사용됩니다.

주요 차이점 요약
통신 방식:
메시지 브로커: 주로 비동기 메시징 시스템으로, 메시지를 큐에 저장하고 소비자가 이를 처리합니다.
웹소켓: 실시간 양방향 통신을 가능하게 하는 프로토콜로, 클라이언트와 서버가 지속적으로 연결된 상태에서 데이터를 주고받습니다.

사용 목적:
메시지 브로커: 다양한 서비스 간의 통신을 중재하고, 메시지의 전달과 라우팅을 담당합니다.
웹소켓: 실시간 데이터를 주고받아야 하는 애플리케이션에서 사용됩니다.

질문2) 웹소켓은 실시간 통신상황에서 주로 쓰이고 메시지 브로커는 실시간 통신이 아니어도 되는 상황에서 쓰는건가?
다시 말해 실시간 통신이 중요하면 메시지 브로커가 아니라 웹소켓을 써야 하는건가?
만약 서버간 통신이 실시간으로 이뤄져야 하는 경우엔 서버끼리 메시지 브로커로 통신하는게아니라 웹소켓을 연결해야 한다는건가?


    메시지 브로커는 메시지 큐를 관리하며, 발신자와 수신자 간의 메시지 전달을 중재하는 시스템입니다. 

    비동기 통신: 
    발신자는 메시지를 큐에 넣고 바로 다른 작업을 할 수 있으며, 
    수신자는 큐에서 메시지를 가져와 처리합니다. 이는 시스템 간의 느슨한 결합을 가능하게 합니다.
    확장성 및 내결함성: 
    메시지 브로커는 메시지를 중간에 저장하고 관리하므로, 
    일시적인 네트워크 문제나 수신자의 처리 속도가 느린 경우에도 메시지를 안전하게 전달할 수 있습니다.
    메시지 보존: 
    메시지 브로커는 메시지를 저장하고 필요에 따라 나중에 전달할 수 있습니다.

    메시지 브로커는 주로 분산 시스템에서 데이터 처리를 관리하거나, 비동기 작업을 처리하는 데 사용됩니다. 
    예를 들어, 로그 수집, 데이터 스트리밍, 비동기 작업 처리 등에 사용됩니다.

    실시간 통신의 필요성에 따른 선택
    실시간 통신이 중요한 경우: 
    웹소켓을 사용하는 것이 적합합니다. 웹소켓은 양방향 실시간 통신을 제공하므로, 빠른 응답이 필요한 경우에 적합합니다.
    실시간 통신이 필수적이지 않은 경우: 
    메시지 브로커를 사용할 수 있습니다. 비동기 통신과 메시지 전달의 안정성이 중요한 경우 메시지 브로커가 더 적합합니다.
    서버 간 통신
    서버 간 통신이 실시간으로 이루어져야 한다면 웹소켓을 사용할 수 있지만, 반드시 그래야 하는 것은 아닙니다. 
    서버 간의 실시간 통신에서도 메시지 브로커를 사용하는 경우가 많습니다. 메시지 브로커를 사용하면 다음과 같은 이점이 있습니다:

    확장성: 여러 서버가 메시지 브로커를 통해 메시지를 주고받을 수 있어, 서버의 추가 및 제거가 용이합니다.
    내결함성: 메시지가 브로커에 안전하게 저장되어, 일시적인 서버 장애 시에도 메시지가 손실되지 않습니다.
    로드 밸런싱: 메시지 브로커는 메시지를 여러 수신자에게 분배하여 로드를 균등하게 할 수 있습니다.
    결론적으로, 실시간 통신이 필요하다고 해서 반드시 웹소켓을 사용해야 하는 것은 아니며, 
    메시지 브로커가 제공하는 다양한 이점들을 고려하여 사용해야 합니다. 어떤 기술을 선택할지는 시스템의 요구사항과 환경에 따라 다릅니다.




메시지 브로커와 웹소켓 모두 TCP/IP 통신을 기반으로 합니다. 그러나 두 방식은 TCP/IP를 사용하는 방식에서 차이가 있습니다.

메시지 브로커는 HTTP를 사용할 수도 있지만, 
일반적으로는 AMQP (Advanced Message Queuing Protocol), 
MQTT (Message Queuing Telemetry Transport), 
STOMP (Simple Text Oriented Messaging Protocol)와 같은 메시지 프로토콜을 사용합니다.
(RabbitMQ - AMQP 사용)

웹소켓은 WebSocket 프로토콜을 사용합니다
웹소켓은 OSI 모델에서 응용 계층(Layer 7) 프로토콜로 간주됩니다. 
초기 연결은 HTTP를 통해 설정되며, HTTP 핸드셰이크 후에 웹소켓 프로토콜로 전환됩니다.

메시지브로커는 응용 계층(Layer 7): AMQP, MQTT, STOMP 등 메시징 프로토콜을 사용합니다


HTTP (HyperText Transfer Protocol)
계층: 응용 계층(Layer 7)
목적: 웹 브라우저와 웹 서버 간의 통신을 위해 주로 사용됩니다. 클라이언트-서버 모델에서 요청-응답 방식으로 작동합니다.
특징:
상태 비저장 프로토콜 (Stateless)
텍스트 기반 프로토콜
주로 웹 페이지, API 통신 등에 사용
메시지 브로커 (Message Broker)
메시지 브로커는 여러 프로토콜을 사용할 수 있으며, 이들 모두 응용 계층(Layer 7)에서 작동합니다. 여기서는 몇 가지 대표적인 프로토콜을 설명하겠습니다.

AMQP (Advanced Message Queuing Protocol):

계층: 응용 계층(Layer 7)
목적: 메시지 지향 미들웨어를 위한 프로토콜로, 메시지의 큐잉, 라우팅, 보안 및 신뢰성을 제공합니다.
사용 예: RabbitMQ, Apache Qpid
MQTT (Message Queuing Telemetry Transport):

계층: 응용 계층(Layer 7)
목적: 저전력 장치와 제한된 대역폭 환경에서 사용하기 위한 경량 메시징 프로토콜.
사용 예: IoT 기기 간 통신, 센서 네트워크
STOMP (Simple Text Oriented Messaging Protocol):

계층: 응용 계층(Layer 7)
목적: 텍스트 기반 프로토콜로, 메시지 브로커와 클라이언트 간의 상호 운용성을 제공합니다.
사용 예: ActiveMQ, Apollo
웹소켓 (WebSocket)
계층: 응용 계층(Layer 7)
목적: 클라이언트와 서버 간의 양방향 통신을 실시간으로 가능하게 하는 프로토콜. 초기 연결은 HTTP를 통해 설정되며, 그 후 WebSocket 프로토콜로 전환됩니다.
특징:
지속적인 연결 (Persistent connection)
양방향 통신 (Full-duplex)
주로 실시간 애플리케이션 (채팅, 게임, 주식 거래 등)에서 사용


