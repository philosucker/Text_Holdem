아키텍쳐 설계시 고려 사항

1. monolithic VS microservice
마이크로 서비스 아키텍쳐 구축
2. API Gateway 서버의 필요성 (API gateway 서버와 Nginx의 차이 텍스트 참고) :
우선 Nginx만 사용
3. HTTP 서버와 웹소켓 서버의 분리  (웹소켓 서버와 메시지 브로커의 통합 텍스트 참고)
(HTTP서버)reception과 (웹소켓 서버)floor, dealer의 분리, agency연결, 웹소켓 서버 간 메시지 브로커 사용
4. kubernetes 로 애플리케이션 배포 및 운영, 인프라 관리의 필요성 (추후 아키텍처 개선 텍스트 참고)
로컬에서 먼저 개발 후 서버리스 아키텍쳐 도입시 전환


각 서버의 역할
   reception 서버의 역할
    1. 사용자 인증 처리 및 사용자 정보를 관리하고, 사용자에게 floor 서버로 접속할 수 있는 권한부여.
   2. floor 서버의 요청시 홀덤 게임에 참여하는 사용자들의 스택사이즈 정보를 DB에서 조회해 floor서버에 전달.
   3. floor 서버의 요청시 게임을 끝낸 사용자들의 스택사이즈를 전달받아 DB 업데이트.

   floor 서버의 역할
    1. 사용자의 테이블 생성, 테이블 참여를 위해 테이블 목록을 DB에 관리 및 사용자들에게 전달.
    2. 홀덤 게임 진행 준비를 위한 데이터를 reception서버 및 dealer 서버 및 agency 서버에 전달.
    3. 사용자와 agency 서버에게 dealer 서버로 접속할 수 있도록 안내.
   4. dealer 서버로부터 게임 과정 및 결과 기록을 보고 받아 사용자와 agency가 활용할 수 있게 관리.

    dealer 서버의 역할
    1. floor서버로부터 전달 받은 데이터를 토대로 dealer_manager 인스턴스들을 호출하고 관리.
     2. 각 dealer_manager들은 사용자들 및 AI agent들과 실시간 통신하며 홀덤 게임 진행.
     3. 게임 과정 및 결과를 floor 서버에 보고.
    
    agency 서버의 역할
    1. floor 서버로부터 전달 받은 게임결과 기록을 agent_manager가 관리하는 강화학습 모델에 전달해 각 홀덤 AI 에이전트들을 훈련
    2. floor 서버의 요청시 agent_manager로 하여금 dealer 서버에 접속할 홀덤 AI 에이전트들을 생성하게 하여 dealer 서버에 전달 
    
위와 같은 구조를 위한 아키텍쳐

1. 마이크로서비스 아키텍처와 컨테이너화

     마이크로서비스 아키텍처와 컨테이너화를 통해 각 서비스의 독립성 보장, 개별 서비스의 확장이 용이하도록 설계. 
    Kubernetes(K8s)를 사용하여 컨테이너 오케스트레이션을 자동화, 서비스 디스커버리 및 로드 밸런싱을 수행.
    Kubernetes를 사용하여 각 서버를 독립적인 마이크로서비스로 배포 및 관리.

2. 이벤트 기반 아키텍처

    이벤트 기반 아키텍처를 통해 서비스 간의 느슨한 결합과 비동기 통신을 지원. 
    메시지 브로커(RabbitMQ)를 사용하여 이벤트 스트림을 관리, 실시간 통신을 처리.

3. 서버리스 아키텍처

   AWS Lambda
    비용 효율성: 사용한 만큼만 비용 지불.
    확장성: 자동 확장을 지원하여 트래픽 급증에도 대응 가능.
    관리 편의성: 인프라 관리 부담 감소.

4. WebSocket을 통한 실시간 통신
    WebSocket을 사용하여 클라이언트와 서버 간의 실시간 양방향 통신을 구현.
    WebSocket 서버를 별도로 두어 dealer 서버 인스턴스와 클라이언트 간의 실시간 통신을 효율적으로 관리.

